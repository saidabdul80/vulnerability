<?php

namespace App\Jobs;
ini_set('memory_limit', '2056M');

use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldBeUnique;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Queue\SerializesModels;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class ProcessJsonUpload implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    /**
     * Create a new job instance.
     *
     * @return void
     */
    protected $filePath;
    protected $zone;
    public $timeout = 900000; // Increase the timeout (in seconds)
    public $tries = 10003; // Increase the number of attempts (default is 3)
    public function __construct($file, $zone)
    {
        $this->filePath = $file;
        $this->zone = $zone;
    }
    /**
     * Execute the job.
     *
     * @return void
     */
    public function handle()
    {                    
        $publicPath = public_path();
        $zone = $this->zone;
        $filePath = $publicPath . DIRECTORY_SEPARATOR . $zone.'.json'; 
        Log::info('process started for - '. $zone);
    
        // Process the JSON file using the provided path
        $batchSize = 500; // You can adjust the batch size
        $batch = [];
    
        $lineNumber = 0;
    
        $fileHandle = fopen($filePath, 'r');
        
            while (!feof($fileHandle)) {
                $line = fgets($fileHandle);
        
                if ($line === false) {
                    break;
                }
        
                $entry = json_decode($line, true);
        
                if ($entry === null || !isset($entry['data'])) {
                    // Handle invalid JSON data
                    continue;
                }
        
                $entries = $entry['data'];
        
                foreach ($entries as $entry) {
                    $lineNumber++;
                    
        
                    $flattenedEntry = collect($entry)->flatMap(function ($values, $key) {   
                        if (is_array($values)) {
                            return array_map('strtoupper', $values);
                        }
                        $value = str_replace('O','0',ucwords($values));
                        $value = str_replace('D','0',ucwords($value));
                        if($key == '1_Data_Collectors_ID'){
                            if(strlen($value) < 3){
                                return array_map('strtoupper', [$key =>str_pad($value,3,"0",STR_PAD_LEFT) ]);
                            }
                            return array_map('strtoupper', [$key =>$value]);
                        }else{
                            return array_map('strtoupper', [$key => $values]);
                        }                     
                    })->all();
        
                    $flattenedEntry["zone"] = $zone;
                    $batch[] = $flattenedEntry;
                    // Insert data in batches
                    if (count($batch) >= $batchSize) {                        
                        // Log the SQL query
                        Log::info('insert');
                        
                    
                        DB::table('survey_data')->insertOrIgnore($batch);
                        $batch = [];
                    }

                }
            }
        
            // Insert any remaining data
            if (!empty($batch)) {
                $chunks = array_chunk($batch, 500);
                foreach ($chunks as $chunk) {
                    DB::table('survey_data')->insertOrIgnore($chunk);
                }
            }
        
            // Close the file handle
            fclose($fileHandle);
            Log::info('process completed for'. $zone);            
        
    }
}
