<?php

namespace App\Http\Controllers;

use App\Imports\UsersImport;
use App\Models\Domain;
use App\Models\LGA;
use App\Models\Subdomain;
use App\Models\SurveyData;
use App\Models\SurveyResponse;
use App\Models\User;
use App\Services\UserService;
use App\Transformers\UtilResource;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Validation\ValidationException;
use Maatwebsite\Excel\Facades\Excel;

class UserController extends Controller
{
    public function __construct(protected UserService $userService)
    {
        
    }

    public function index()
    {
        try {            
            $users = $this->userService->getAllUsers();
            return new UtilResource($users, false, 200);
        } catch (\Exception $e) {
            return new UtilResource($e->getMessage(), true, 400);
        }
    }

    public function show($id)
    {
        try {
            $user = $this->userService->getUserById($id);
            return new UtilResource($user, false, 200);
        } catch (\Exception $e) {
            return new UtilResource($e->getMessage(), true, 400);
        }
    }

    public function store(Request $request)
    {
        try {
            // Validation rules and custom error messages
            $rules = [
                'name' => 'required|string',
                'email' => 'required|email|unique:users,email',
                'gender' => 'required|string',
                'age' => 'required|integer',
                'ward_ids' => 'required|array',
                'phone_number' => 'required|string',
            ];

            $messages = [
                'name.required' => 'Name is required.',
                'email.required' => 'Email is required.',
                'email.email' => 'Invalid email format.',
                'email.unique' => 'Email is already taken.',
                // Add more custom error messages as needed
            ];

            // Validate the request data
            $request->validate($rules, $messages);

            // Create a new user
            $user = User::create([
                'name' => $request->input('name'),
                'email' => $request->input('email'),
                'gender' => $request->input('gender'),
                'age' => $request->input('age'),
                'ward_ids' =>implode(',',$request->input('ward_ids')),
                'phone_number' => $request->input('phone_number'),
            ]);

            if ($user) {
                return redirect()->route('upload.excel')->with('success', 'User added successfully.');
            } else {
                return redirect()->route('upload.excel')->with('error', 'Failed to add user.');
            }
        } catch (ValidationException $e) {
            return redirect()->route('upload.excel')->with('error', $e->getMessage())->withErrors($e->errors());
        } catch (\Exception $e) {
            return redirect()->route('upload.excel')->with('error', 'An error occurred while adding the user.');
        }
    }

    public function questions(){
        
        try{
            $response = Subdomain::get();
            return response()->json([
                'status' => 'success',
                'message' =>$response
            ]);
        }catch(\Exception $e){
            return response()->json([                
                'message' => $e->getMessage()
            ], 400);
        }
    }


    public function lgas(){
        
        try{
            $response = LGA::with('wards')->get();
            return response()->json([
                'status' => 'success',
                'message' =>$response
            ]);
        }catch(\Exception $e){
            return response()->json([                
                'message' => $e->getMessage()
            ], 400);
        }
    }
    
    public function importExcel(Request $request)
    {
        $file = $request->file('file');

        Excel::import(new UsersImport, $file);

        return redirect()->route('users.index')
            ->with('success', 'Excel data imported to users table successfully.');
    }

    public function userIndex()
    {
        $users = User::latest()->get();
        return view('users_index', ['users' => $users]);
    }

    public function uploadIndex()
    {        
        return view('upload_excel');
    }
    
    public function uploadData(Request $request){
        try{
            $request->validate([
                'data'=>'required',
                'user_id'=>'required'
            ]);
            $data = $request->input('data');
            $formatted = [];
            $now = now(); // Assuming now() returns the current timestamp.            
            foreach ($data as $dat) {
                $token = $request->input('user_id').'_'.rand(1000000000000000,9999999999999999);
                foreach ($dat as $d) {
                    $formatted[] = [
                        'user_id'=> $request->input('user_id'),
                        'domain_id' => $d['domain_id'],
                        'subdomain_id' => $d['id'],
                        'answer' => $d['answer'],
                        'token' =>$token,
                        'created_at' => $now,
                    ];
                }
            }
            
            if (!empty($formatted)) {
                SurveyResponse::insert($formatted);
            }
            return response()->json([
                'status' => 'success',
                'message' =>'Uploaded'
            ]);
        }catch(\Exception $e){
            return response()->json([                
                'message' => $e->getMessage()
            ], 400);
        }
    }
    

    public function getAllResponses()
    {
            // Fetch the data            
        $domain_id = 8;
        $responses = DB::table('survey_responses')
        ->join('subdomains', 'survey_responses.subdomain_id', '=', 'subdomains.id')
        ->select('survey_responses.token', 'subdomains.name as subdomain_name', 'survey_responses.answer')
        ->where('subdomains.domain_id', $domain_id)
        ->get();

        // Create an associative array for the dynamic columns
        $dynamicColumns = [];

        foreach ($responses as $response) {
        $token = $response->token;
        $subdomainName = $response->subdomain_name;
        $answer = $response->answer;

        // Use the subdomain name as a key and token as a value
        $dynamicColumns[$token][$subdomainName] = $answer;
        }

        // Now you have an associative array where the keys are tokens and values are arrays with subdomain names and answers

        return response()->json(['responses' => $dynamicColumns]);
    }

    public function uploadJsonindex()
    {
        return view('json_upload'); // Assuming you have a Blade view named 'upload.blade.php'
    }
    public function uploadJson(Request $request) {
        // Validate the request
        $request->validate([
            'file' => 'required',
            'zone' => 'required|in:ZONE_A,ZONE_B,ZONE_C', // Add more zones as needed
        ]);
    
        $zone = $request->zone;
    
        // Retrieve the uploaded JSON file
        $file = $request->file('file');
    
        // Process the JSON file using a streaming approach
        $batchSize = 1000; // You can adjust the batch size
        $batch = [];
    
        $lineNumber = 0;
    
        $fileHandle = fopen($file->path(), 'r');
    
        while (!feof($fileHandle)) {
            $line = fgets($fileHandle);
    
            if ($line === false) {
                break;
            }
    
            $entry = json_decode($line, true);
    
            if ($entry === null || !isset($entry['data'])) {
                // Handle invalid JSON data
                continue;
            }
    
            $entries = $entry['data'];
    
            foreach ($entries as $entry) {
                $lineNumber++;
    
                $flattenedEntry = collect($entry)->flatMap(function ($values, $key) {
                    if (is_array($values)) {
                        return array_map('strtoupper', $values);
                    }
                    return array_map('strtoupper', [$key => $values]);
                })->all();
    
                $flattenedEntry["zone"] = $zone;
                $batch[] = $flattenedEntry;
    
                // Insert data in batches
                if (count($batch) >= $batchSize) {
                    DB::table('survey_data')->insertOrIgnore($batch);
                    $batch = [];
                }
            }
        }
    
        // Insert any remaining data
        if (!empty($batch)) {
            $chunks = array_chunk($batch, 5000);
            foreach ($chunks as $chunk) {
                DB::table('survey_data')->insertOrIgnore($chunk);
            }
        }
    
        // Close the file handle
        fclose($fileHandle);
    
        // Return a response indicating success
        return response()->json(['message' => 'Data processed and stored in batches successfully']);
    }
    
    public  function fetch(Request $request){
        try{

            $zone = $request->zone??"ZONE_A";
            $surveyData = SurveyData::select('1_Data_Collectors_ID','2_Ward','9_Age_Range','10_Marital_Status','11_Gender')->search($zone)->get();
            return $surveyData;
        }catch(\Exception $e){
            return $e->getMessage();
        }
        //return response()->json($surveyData);
    }
}
